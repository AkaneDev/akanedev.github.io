<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Rogue — Responsive</title>
<style>
  :root{
    --bg:#071122;
    --panel:#0f1724;
    --accent:#6ee7b7;
    --muted:#94a3b8;
  }
  *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  body{
    margin:0;
    background:linear-gradient(180deg,#051021 0%,#081529 100%);
    color:#e6eef8;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    min-height:100vh;
    padding:2vw;
    overflow:hidden;
  }
  .wrap{display:flex;flex-wrap:wrap;justify-content:center;gap:2vw;align-items:flex-start;width:100%;max-width:1200px;}
  .boardWrap{
    background:var(--panel);
    padding:1vw;
    border-radius:12px;
    box-shadow:0 8px 30px rgba(2,6,23,.6);
    flex:1 1 320px;
    display:flex;
    justify-content:center;
  }
  canvas{background:#071025;border-radius:8px;display:block;max-width:100%;height:auto;}
  .side{
    flex:1 1 300px;
    background:linear-gradient(180deg,rgba(255,255,255,.01),transparent);
    padding:1vw;
    border-radius:8px;
    min-width:260px;
  }
  h1{margin:0 0 8px;color:var(--accent);font-size:clamp(1.2rem, 2vw, 1.8rem);}
  .statRow{display:flex;gap:8px;margin-bottom:8px;}
  .card{flex:1;background:rgba(255,255,255,.02);padding:8px;border-radius:8px;text-align:center;font-size:clamp(0.8rem,1.2vw,1rem);}
  .smallCanvas{background:#051217;border-radius:6px;display:block;margin:8px auto;max-width:100%;height:auto;}
  .mods{max-height:200px;overflow:auto;padding:6px;border-radius:6px;background:rgba(255,255,255,.02);font-size:13px;}
  .controls{font-size:13px;color:var(--muted);line-height:1.6;margin-top:8px;}
  .btn{display:inline-block;padding:10px 12px;border-radius:8px;background:rgba(255,255,255,.03);cursor:pointer;margin-top:8px;width:100%;font-size:clamp(0.9rem,1.3vw,1rem);}
  .overlay{
    position:fixed;inset:0;background:rgba(0,0,0,.85);
    display:none;align-items:center;justify-content:center;color:#fff;
    flex-direction:column;z-index:99;padding:20px;text-align:center;
  }
  .choice{background:#0b1622;border-radius:8px;padding:12px;margin:8px;cursor:pointer;
          border:1px solid rgba(255,255,255,.03);min-width:260px;width:80%;max-width:320px;}
  .choice:hover{background:#12202a;}
  .muted{color:var(--muted);}
  @media (max-width:900px){
    body{align-items:center;padding:4vw;}
    .wrap{flex-direction:column;align-items:center;}
    .boardWrap{width:100%;max-width:90vw;}
    #board{width:100%;height:auto;}
    .side{width:100%;max-width:90vw;}
    .mods{max-height:150px;}
  }
  @media (max-width:500px){
    .statRow{flex-direction:column;}
    .card{font-size:0.9rem;}
    h1{font-size:1.4rem;}
    .controls{font-size:0.85rem;}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="boardWrap">
      <canvas id="board" width="300" height="600"></canvas>
    </div>
    <div class="side">
      <h1>Tetris Rogue</h1>
      <div class="statRow">
        <div class="card">Score<br><strong id="score">0</strong></div>
        <div class="card">Level<br><strong id="level">1</strong></div>
      </div>
      <div class="statRow">
        <div class="card">Lines<br><strong id="lines">0</strong></div>
        <div class="card">Goal<br><strong id="goal">5</strong></div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;margin-top:6px">
        <div style="flex:1;text-align:center">
          <div class="muted">Hold</div>
          <canvas id="holdCanvas" class="smallCanvas" width="120" height="120"></canvas>
        </div>
        <div style="flex:1;text-align:center">
          <div class="muted">Next</div>
          <canvas id="nextCanvas" class="smallCanvas" width="120" height="120"></canvas>
        </div>
      </div>
      <div style="margin-top:10px">
        <div class="muted">Active Modifiers</div>
        <div id="modsList" class="mods"><em class="muted">None</em></div>
      </div>
      <div class="controls">
        <strong>Controls</strong><br>
        ← / → : Move<br>
        ↑ : Rotate<br>
        ↓ : Soft drop<br>
        Space : Hard drop<br>
        C / Shift : Hold / Swap<br>
        Esc : Restart
      </div>
      <div style="margin-top:12px">
        <button id="btnPause" class="btn">Pause</button>
        <button id="btnRestart" class="btn">Restart</button>
      </div>
    </div>
  </div>
  <div id="modOverlay" class="overlay"></div>

<script>
const COLS=10,ROWS=20;
let BLOCK=30;
const board=document.getElementById("board"),ctx=board.getContext("2d");
const nextCanvas=document.getElementById('nextCanvas'),nextCtx=nextCanvas.getContext('2d');
const holdCanvas=document.getElementById('holdCanvas'),holdCtx=holdCanvas.getContext('2d');
const scoreEl=document.getElementById('score'),levelEl=document.getElementById('level'),
      linesEl=document.getElementById('lines'),goalEl=document.getElementById('goal');
const modsListEl=document.getElementById('modsList'),overlay=document.getElementById('modOverlay');

const SHAPES={I:[[1,1,1,1]],J:[[1,0,0],[1,1,1]],L:[[0,0,1],[1,1,1]],O:[[1,1],[1,1]],S:[[0,1,1],[1,1,0]],T:[[0,1,0],[1,1,1]],Z:[[1,1,0],[0,1,1]]};
const COLORS={I:'#60f',J:'#36c',L:'#f93',O:'#fc0',S:'#2bfa8a',T:'#b76cff',Z:'#ff5c8a'};

let grid=[],current=null,nextPiece=null,hold=null,canHold=true,score=0,level=1,lines=0,goalBase=5;
let dropInterval=800,dropCounter=0,lastTime=0,paused=false,gameOver=false;
let activeMods=[],controlsReversed=false;

function makeGrid(){return Array.from({length:ROWS},()=>Array(COLS).fill(null));}
function clone(s){return s.map(r=>r.slice());}
function makePiece(t=null){const k=Object.keys(SHAPES);const type=t||k[Math.floor(Math.random()*k.length)];
 return {type,shape:clone(SHAPES[type]),x:Math.floor((COLS-SHAPES[type][0].length)/2),y:-1,color:COLORS[type]};}
function rotate(mat){const h=mat.length,w=mat[0].length;const o=Array.from({length:w},()=>Array(h).fill(0));
 for(let r=0;r<h;r++)for(let c=0;c<w;c++)o[c][h-1-r]=mat[r][c];return o;}
function collides(p){for(let r=0;r<p.shape.length;r++)for(let c=0;c<p.shape[0].length;c++){if(!p.shape[r][c])continue;
 let gx=p.x+c,gy=p.y+r;if(gx<0||gx>=COLS||gy>=ROWS)return true;if(gy>=0&&grid[gy][gx])return true;}return false;}
function merge(p){for(let r=0;r<p.shape.length;r++)for(let c=0;c<p.shape[0].length;c++){if(p.shape[r][c]){
 let gx=p.x+c,gy=p.y+r;if(gy>=0&&gy<ROWS&&gx>=0&&gx<COLS)grid[gy][gx]=p.color;}}}
function clearLines(){let cleared=0;
 for(let r=ROWS-1;r>=0;r--){if(grid[r].every(v=>v)){grid.splice(r,1);grid.unshift(Array(COLS).fill(null));cleared++;r++;}}
 if(cleared){lines+=cleared;score+=cleared*100*level;updateStats();checkLevel();}}
function drawCell(x,y,c,a=1){ctx.globalAlpha=a;ctx.fillStyle=c;ctx.fillRect(x*BLOCK+1,y*BLOCK+1,BLOCK-2,BLOCK-2);ctx.globalAlpha=1;}
function drawBoard(){
 ctx.clearRect(0,0,board.width,board.height);ctx.fillStyle='#071025';ctx.fillRect(0,0,board.width,board.height);
 for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(grid[r][c])drawCell(c,r,grid[r][c]);
 if(current){
  let g={...current,shape:clone(current.shape)};
  while(!collides({...g,y:g.y+1}))g.y++;
  for(let r=0;r<g.shape.length;r++)for(let c=0;c<g.shape[0].length;c++)if(g.shape[r][c])drawCell(g.x+c,g.y+r,current.color,0.14);
  for(let r=0;r<current.shape.length;r++)for(let c=0;c<current.shape[0].length;c++)if(current.shape[r][c])drawCell(current.x+c,current.y+r,current.color,1);
 }
 ctx.strokeStyle='rgba(255,255,255,0.03)';for(let x=0;x<=COLS;x++){ctx.beginPath();ctx.moveTo(x*BLOCK,0);ctx.lineTo(x*BLOCK,ROWS*BLOCK);ctx.stroke();}
 for(let y=0;y<=ROWS;y++){ctx.beginPath();ctx.moveTo(0,y*BLOCK);ctx.lineTo(COLS*BLOCK,y*BLOCK);ctx.stroke();}
}
function drawPreview(cvsCtx,piece){const w=cvsCtx.canvas.width,h=cvsCtx.canvas.height;
 cvsCtx.clearRect(0,0,w,h);cvsCtx.fillStyle='#051217';cvsCtx.fillRect(0,0,w,h);if(!piece)return;
 const cell=Math.min(w/(piece.shape[0].length+1),h/(piece.shape.length+1));
 const ox=(w-piece.shape[0].length*cell)/2,oy=(h-piece.shape.length*cell)/2;
 for(let r=0;r<piece.shape.length;r++)for(let c=0;c<piece.shape[0].length;c++)if(piece.shape[r][c]){
 cvsCtx.fillStyle=piece.color;cvsCtx.fillRect(ox+c*cell+4,oy+r*cell+4,cell-8,cell-8);}}
function spawn(){if(!nextPiece)nextPiece=makePiece();current=nextPiece;nextPiece=makePiece();canHold=true;
 if(collides(current))setTimeout(()=>restart(),100);renderPreviews();}
function hardDrop(){while(!collides({...current,y:current.y+1}))current.y++;merge(current);clearLines();spawn();}
function softDrop(){current.y++;if(collides(current)){current.y--;merge(current);clearLines();spawn();}}
function holdPiece(){if(!canHold)return;
 if(!hold){hold={...current,shape:clone(current.shape)};spawn();}else{const t={...hold,shape:clone(hold.shape)};hold={...current,shape:clone(current.shape)};current=t;current.x=Math.floor((COLS-current.shape[0].length)/2);current.y=-1;if(collides(current))spawn();}
 canHold=false;renderPreviews();}
function updateStats(){scoreEl.textContent=score;levelEl.textContent=level;linesEl.textContent=lines;goalEl.textContent=goalBase*level;
 modsListEl.innerHTML=activeMods.length?activeMods.map(m=>`<div><strong>${m.name}</strong><div class="muted" style="font-size:12px">${m.type}</div></div>`).join(''):'<em class="muted">None</em>'; }
function checkLevel(){if(lines>=goalBase*level){level++;dropInterval=Math.max(80,Math.floor(dropInterval*0.92));updateStats();}}
function renderPreviews(){drawPreview(nextCtx,nextPiece);drawPreview(holdCtx,hold);updateStats();}
window.addEventListener('keydown',e=>{
 if(e.code==='Escape')return restart();if(paused||gameOver)return;
 let k=e.code;if(controlsReversed){if(k==='ArrowLeft')k='ArrowRight';else if(k==='ArrowRight')k='ArrowLeft';}
 if(k==='ArrowLeft'){current.x--;if(collides(current))current.x++;}
 else if(k==='ArrowRight'){current.x++;if(collides(current))current.x--;}
 else if(k==='ArrowUp'){const old=clone(current.shape);current.shape=rotate(current.shape);if(collides(current))current.shape=old;}
 else if(k==='ArrowDown'){softDrop();}
 else if(k==='Space'){hardDrop();}
 else if(k==='KeyC'||k==='ShiftLeft'||k==='ShiftRight'){holdPiece();}
 renderPreviews();
});
document.getElementById('btnPause').onclick=()=>{paused=!paused;btnPause.textContent=paused?'Resume':'Pause';if(!paused)lastTime=performance.now();};
document.getElementById('btnRestart').onclick=()=>restart();

function update(t=0){if(!lastTime)lastTime=t;const d=t-lastTime;lastTime=t;
 if(!paused&&current){dropCounter+=d;if(dropCounter>dropInterval){current.y++;if(collides(current)){current.y--;merge(current);clearLines();spawn();}dropCounter=0;}}
 drawBoard();requestAnimationFrame(update);}
function restart(){grid=makeGrid();current=null;nextPiece=makePiece();hold=null;canHold=true;
 score=0;level=1;lines=0;dropInterval=800;dropCounter=0;goalBase=5;paused=false;gameOver=false;activeMods=[];
 updateStats();spawn();lastTime=performance.now();requestAnimationFrame(update);}
grid=makeGrid();spawn();updateStats();requestAnimationFrame(update);

// ---------- AUTO-RESIZE (Canvas Only) ----------
function resizeBoard(){
  const wrap = document.querySelector('.boardWrap');
  const maxW = Math.min(wrap.clientWidth, window.innerWidth * 0.9);
  const maxH = Math.min(window.innerHeight * 0.9, maxW * 2); // keep 1:2 ratio

  const newWidth = Math.min(maxW, maxH / 2);
  const newHeight = newWidth * 2;

  board.width = newWidth;
  board.height = newHeight;
  board.style.width = newWidth + 'px';
  board.style.height = newHeight + 'px';
  BLOCK = newWidth / COLS;
}
window.addEventListener('resize', resizeBoard);
window.addEventListener('load', resizeBoard);
</script>
</body>
</html>
