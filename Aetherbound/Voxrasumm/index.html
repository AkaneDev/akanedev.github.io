<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aetherbound Spell Creator</title>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-100 font-sans p-6">

<h1 class="text-3xl font-bold mb-6 text-center">Aetherbound Spell Creator</h1>

<div class="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-3 gap-6">

  <!-- Spell Workspace -->
  <div class="bg-gray-800 p-4 rounded col-span-1 md:col-span-2">
    <h2 class="text-xl font-semibold mb-2">Spell Workspace</h2>
    <div id="spellWorkspace" class="bg-gray-700 p-2 rounded min-h-[120px] mb-2 flex flex-wrap gap-2 overflow-x-auto">
      <!-- Rune chips appear here -->
    </div>
    <textarea id="spellIncantation" rows="2" readonly 
      class="w-full p-2 rounded bg-gray-900 text-gray-100" 
      placeholder="Your spell incantation will appear here..."></textarea>
    <div class="mt-2 flex gap-2">
      <button id="clearWorkspace" class="px-4 py-2 bg-red-600 rounded hover:bg-red-500 flex-1">Clear Spell</button>
      <button id="exportSpell" class="px-4 py-2 bg-green-600 rounded hover:bg-green-500 flex-1">Copy Spell</button>
    </div>
  </div>

  <!-- Lexicon Search & Presets -->
  <div class="bg-gray-800 p-4 rounded">
    <h2 class="text-xl font-semibold mb-2">Lexicon & Presets</h2>

    <!-- Search Runes -->
    <input id="searchInput" type="text" placeholder="Search runes, English words..." 
      class="w-full p-2 rounded bg-gray-700 mb-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">

    <div class="overflow-y-auto max-h-64 mb-2">
      <table class="w-full table-auto border-collapse border border-gray-700">
        <thead>
          <tr class="bg-gray-700">
            <th class="border border-gray-600 px-2 py-1 text-left">Rune</th>
            <th class="border border-gray-600 px-2 py-1 text-left">Pronunciation</th>
            <th class="border border-gray-600 px-2 py-1 text-left">English Words</th>
          </tr>
        </thead>
        <tbody id="lexiconTable" class="divide-y divide-gray-700">
          <!-- Populated dynamically -->
        </tbody>
      </table>
    </div>

    <!-- Advanced Natural Language Spell Input -->
    <input id="nlInput" type="text" placeholder="Type spell description e.g. 'wave of fireball'" 
      class="w-full p-2 rounded bg-gray-700 mb-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
    <button id="parseSpell" class="px-4 py-2 bg-indigo-600 rounded hover:bg-indigo-500 w-full mb-4">Parse Spell</button>

    <!-- Preset Spells -->
    <h3 class="text-lg font-semibold mb-2">Preset Spells</h3>
    <div id="presetContainer" class="flex flex-col gap-2 max-h-64 overflow-y-auto">
      <!-- Presets loaded from server -->
    </div>
  </div>
</div>

<!-- Modal for multiple rune choices -->
<div id="runeModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden">
  <div class="bg-gray-800 p-4 rounded max-w-lg w-full">
    <h3 class="text-lg font-semibold mb-2">Choose a rune:</h3>
    <div id="runeChoices" class="flex flex-wrap gap-2"></div>
    <button id="closeModal" class="mt-4 px-4 py-2 bg-red-600 rounded hover:bg-red-500">Cancel</button>
  </div>
</div>

<script>
let lexicon = [];
let spellRunes = [];
let presets = [];

// Load CSV lexicon
async function loadLexicon() {
  const response = await fetch('lexicon.csv');
  const text = await response.text();
  const rows = text.trim().split('\n').filter(line => line && !line.startsWith('#')).slice(1);
  lexicon = rows.map(row => {
    const [rune, pronunciation, english] = row.split(',');
    return { rune, pronunciation, english: english.replace(/^\[|\]$/g,'').split('|') };
  });
  renderTable(lexicon);
}

// Render lexicon table
function renderTable(data) {
  const table = document.getElementById('lexiconTable');
  table.innerHTML = '';
  data.forEach(entry => {
    const row = document.createElement('tr');
    row.classList.add('cursor-pointer', 'hover:bg-gray-700');
    row.innerHTML = `
      <td class="border border-gray-600 px-2 py-1">${entry.rune}</td>
      <td class="border border-gray-600 px-2 py-1">${entry.pronunciation}</td>
      <td class="border border-gray-600 px-2 py-1">${entry.english.join(', ')}</td>
    `;
    row.addEventListener('click', () => addRune(entry.rune));
    table.appendChild(row);
  });
}

// Add rune to workspace
function addRune(rune) {
  spellRunes.push(rune);
  updateWorkspace();
}

// Remove rune
function removeRune(index) {
  spellRunes.splice(index, 1);
  updateWorkspace();
}

// Update workspace display
function updateWorkspace() {
  const container = document.getElementById('spellWorkspace');
  container.innerHTML = '';
  spellRunes.forEach((r, i) => {
    const span = document.createElement('span');
    span.textContent = r;
    span.className = 'bg-indigo-600 px-2 py-1 rounded cursor-pointer hover:bg-indigo-500';
    span.addEventListener('click', () => removeRune(i));
    container.appendChild(span);
  });
  document.getElementById('spellIncantation').value = spellRunes.join(' ');
}

// Setup search
document.getElementById('searchInput').addEventListener('input', e => {
  const q = e.target.value.toLowerCase();
  const filtered = lexicon.filter(entry => 
    entry.rune.toLowerCase().includes(q) ||
    entry.pronunciation.toLowerCase().includes(q) ||
    entry.english.some(e => e.toLowerCase().includes(q))
  );
  renderTable(filtered);
});

// Parse natural language spell
document.getElementById('parseSpell').addEventListener('click', () => {
  const input = document.getElementById('nlInput').value.toLowerCase().replace(/ of /g,' ');
  const words = input.split(/\s+/);
  parseSpellWords(words);
});

// Parse words to runes
function parseSpellWords(words) {
  if (!words.length) return;
  let index = 0;

  function nextWord() {
    if (index >= words.length) return;
    const word = words[index];
    const candidates = lexicon.filter(e => e.english.some(en => en.toLowerCase() === word));
    if (candidates.length === 0) {
      index++;
      nextWord();
    } else if (candidates.length === 1) {
      addRune(candidates[0].rune);
      index++;
      nextWord();
    } else {
      showRuneModal(candidates, selected => {
        addRune(selected.rune);
        index++;
        nextWord();
      });
    }
  }
  nextWord();
}

// Modal for multiple rune choices
function showRuneModal(candidates, callback) {
  const modal = document.getElementById('runeModal');
  const choices = document.getElementById('runeChoices');
  choices.innerHTML = '';
  candidates.forEach(c => {
    const btn = document.createElement('button');
    btn.textContent = `${c.rune} (${c.english.join(', ')})`;
    btn.className = 'bg-indigo-600 px-2 py-1 rounded hover:bg-indigo-500';
    btn.addEventListener('click', () => {
      modal.classList.add('hidden');
      callback(c);
    });
    choices.appendChild(btn);
  });
  modal.classList.remove('hidden');
}

// Close modal
document.getElementById('closeModal').addEventListener('click', () => {
  document.getElementById('runeModal').classList.add('hidden');
});

// Clear workspace
document.getElementById('clearWorkspace').addEventListener('click', () => {
  spellRunes = [];
  updateWorkspace();
});

// Export spell to clipboard
document.getElementById('exportSpell').addEventListener('click', () => {
  navigator.clipboard.writeText(spellRunes.join(' '));
  alert('Spell copied to clipboard!');
});

// Load preset spells from server
async function loadPresets() {
  const response = await fetch('presets.json');
  presets = await response.json(); // Expect [{name:"Wave of Fire", runes:["voryn","pyra","vara"]}, ...]
  const container = document.getElementById('presetContainer');
  container.innerHTML = '';
  presets.forEach(p => {
    const btn = document.createElement('button');
    btn.textContent = p.name;
    btn.className = 'bg-green-600 px-2 py-1 rounded hover:bg-green-500 text-left';
    btn.addEventListener('click', () => {
      spellRunes.push(...p.runes);
      updateWorkspace();
    });
    container.appendChild(btn);
  });
}

loadLexicon();
loadPresets();

</script>
</body>
</html>
